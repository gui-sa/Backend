Links Tops:
    https://developer.mozilla.org/pt-BR/

JavaScript is the programming language that runs scripts inside a browser :: in other world it is client side processing!
    That way, you can send functional scripts to the client's machine run, instead of your server.
    You can also use it to perform animations and others interesting things in the browser. 

Name/Value Pair: name that match to a UNIQUE VALUE
    Address = 'Bazinga - 100'

Objects: Collection of Name/Value Pair. (In JS)
    Address:
    {
        Street:'Bazinga',
        Number: 100,
        Apartment:
        {
            Floor: 3,
            Number: 13,
        }
    }

Global Environment: It runs inside a execution context. It is accessible anywhere in the code.
    It creates a global Object
    It creates special variable 'this'.
        Usually, by default in global level its value is window... Windows of the browser

Window: Object that refers to browser window.
    When you are using others frameworks, the window object (global object) is diferent... But, there will be always one.

Global Object: Is created by Global Environment/Executor

Global: something that are not inside a function

Tab: each tab is a separate process, in other words, it is another global indepedent context.

Variables outside a funtion get atached to  the global object

Outer Environment: It is a reference to the oldest execution context. 

Hoisting: First the javascript is separate memory for each var without running by Exercution Context.
    1) Creationg Phase: Global Object, this, Outer Environment, parser recognizes variables and function and set up memory space for them!
        So, this variables and functions already have the vars and function before running it.
        Due the javascript doesnt know how many space it needs for its variables, it just put a placeholder named: undefined;
            All varibles are initially setted  as undefined 
        Funtions are sitting in memory entirely
    2) Running Phase: single threaded, line by line from top to down.
    Bad idea to count on hoisting!!


Placeholder undefined: it is not a string! It is a especial value to refers to it... Not defininig is diferent from not undefined
    You can reference it by keyword undefined to compare things
    DO NOT set something as undefined!

When you run a code it creates de Global Execution Context.. When you call a function, it creates a new execution context just for that function...
    A Stack is created... The new Context atop the older context... It is named Execution Stack
    All the functions is already up in the memory at global execution context creation
    Every execution context has its own variable Environment (scope)
        Each one is dintict, unique and independent from each other;


let: works just like var and is setted up just like var in the creation phase (and so, initially, setted as undefined). However, when let is used, javascript blocks the hoisting.
    declared between blocks... {}... is valid just inside it.
        So, when you use it inside a for, each one is a new variable...
            BLOCK SCOPING

Javascript has hooks with Rendering Engine and HTTP Requests...

Assincronous: Others codes and engines of Browser running tasks
    We are talking about Rendering Engines, HTTP Requests, events Queue. 
    They are assigned when the Execution Context Stack is finished.

Event Queue: sits inside javascript engine... notifications of events that might be happening.
    The browser Assincronously, puts events in this events Queue

JavaScript uses Dynamic Typing.

There are 5 Primitive Types in JS (even thought you dont choose it directly):
    1. undefined --  variable was created but not assigned
    2. NULL -- variable has no data but has existed
    3. Boolean -- true/false
    4. Strings -- cadeia de chars
    5. Numbers -- always float
    6. Simbols -- ?

Precedence and Associtivity: The Higher, the one that is called first.
    https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

Default Values: Each var or has default value when converted to others types (coeecions)

Samaness Compatison: When using === sameness comparison you avoid the coercion and then the type are also compared. This avoids BUGS.

Objects and Functions they are related.

Objects are colection of name-value pairs :: they have and address
    Primitive :: property :: they have one address
        Another child object can be also a property
    Method ::  Funtions connected to an object :: they have address


Computed Member Access Operator: these are the bracket [] ... It creates a reference to something as property
    You can create objects thru strings passed dinamicly
Member Access Operator: Used to access properties and methods of and object: .
    You can create a fixed name to be a property

Shorthand Object : Curly Brace {} is used to create an object;

Funtions in JavaScript are objects
    Primitive
    Object
    Others Functions
    Name: can be anonymous
    Code.. especial propety thar are invocable using ()
        A net execution context is created. (Creationg Phase)
            Variable Environment : news ones
            Outer Environment: lexical envioronment
            'this' is created => a variable. It points to a diferent object dependending on how the function was invoked;
        They also have some "methods" called:
        .bind()
            It binds a function to an object properties... including `this` property
            It also can be used to create a Currying function!
            check bindFunction1 to more details!
        .call()
            It calls a function binding it to some object
        .apply()
        
    You can have a function statement in which just do work and dont return nothing
        You can have a function expression, that return something

By value vs by reference
	BY VALUE: A variable has a memory location.
		se a = 10
		b = a
		b tera um novo local na memoria e o valor de a sera copiado e atribuido
	By Reference: works for all objects. They has a memory location
		se a = new Abject()
		b = a
		b tera a mesma referencia e se eu alterar o a, b vai alterar tambem. nesse caso os valores nao sao copiados e sim as referencias;

THIS keyword.
    this outside any function will appoint to window object.
    inside a function it still will point to window (if simply invoked)
    IF the function is inside an object it will point to the parent object!
        

Arrays: collection of things insider of it = using []
    In JS you can put in a array whatever type you want.

Default arguments can be done using || statement:
    function(name) = {
        name = name||"Esse eh o valor default";
    }


Execution Context is created (function)
    Variable Environment
    'this'
    Outer Environment
    'arguments'
        Array like: acts like array, but it is not.
        You can use arguments to avoid running a function by comparing the value or legnth of the array
        Is getting deprecated.

SPREAD OPERATOR ...NomeVAR: its used in the argumetns to express extra arguments... will be treated as a list

Function Overloading: JS doesnt have any: functions of the same name however with diferent number of parameters (and in some case, difewrent types)
    doesnt work in js because functions are objects
    We can simulate something like that by design patterns


Sintax Parsers: There are a JS engine that parsers your code and turns it into machine code.
    JS parses your code character by character assuming things...

DANGEROUS THINGS:
    Automatic semicolon assertions (;): You dont need to put it, because it usually assumes it for you, HOWEVER, it is dangerous! ALWAYS put ; Dont let JS engine decide to you in your place.
        Mainly if there are a carriage return... \n in which it usually assumes as ;
    

Safe Code IIFE and packages:
    when you call script inside and html things gets only stacked one on another one...
    That makes extremmely easy to mix up variables names and actually break something.
    The trick is, create every script inside an IIFE.
    That way JS creates a new executable context that has a separated scope!
    (funtion(...atr){
        //codes
    })();

Closure: It is an effect of js that happens when a context is created and while in it, some object is created (due some past actions or properties) that context so comes to an end, however its object no.
    But, that object rememenbers some varibles and properties from past contexts!
    That is enclosure
    Example:

    function greetFactory(language){
        language = language || "en";
        return function(firstName,lastName){
            switch(language){
                case "en":
                    console.log(`Hello ${firstName}!`);
                    break;

                case "es":
                    console.log(`Hola ${firstName}`);
                    break;
                default:
                    throw new Error("Language not found!");
                    break;
            }
        }
    }

    Even tho it is not the best factory... It is a good example to explain closure.

    Other good example: look at ClosureAndCallback exercise;